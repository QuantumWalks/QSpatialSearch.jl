<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>New dynamics · QuantumWalk</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/logo.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="QuantumWalk logo"/></a><h1>QuantumWalk</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="type_hierarchy.html">Type hierarchies</a></li><li><span class="toctext">Dynamics</span><ul><li><a class="toctext" href="quantum_walk.html">Quantum walk evolution</a></li><li><a class="toctext" href="quantum_search.html">Quantum search</a></li></ul></li><li><span class="toctext">Walk models</span><ul><li><a class="toctext" href="ctqw.html">CTQW model</a></li><li><a class="toctext" href="szegedy.html">Szegedy model</a></li></ul></li><li class="current"><a class="toctext" href="new_dynamics.html">New dynamics</a><ul class="internal"><li><a class="toctext" href="#New-dynamics-1">New dynamics</a></li></ul></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="citing.html">Citing</a></li><li><a class="toctext" href="license.html">Licence</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="new_dynamics.html">New dynamics</a></li></ul><a class="edit-page" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/master/docs/src/new_dynamics.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>New dynamics</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="New-dynamics-1" href="#New-dynamics-1">New dynamics</a></h2><p>The main purpose of the package is to provide easy extendability of the code. As Quantum walk models needs to be adjusted to existing dynamics, the key is to defined an describe dynamic. As an example we propose an example of simple dynamic determining the period of the model.</p><pre><code class="language-julia">struct QWPeriod{T} &lt;: QWDynamics{T}
  model::T
  parameters::Dict{Symbol,Any}

  function QWPeriod(model::T,
                    parameters::Dict{Symbol}) where T&lt;:QWModelDiscr
    check_qwdynamics(QWPeriod, model, parameters)
    new{T}(model, parameters)
  end
end

function determine_period(qwp::QWPeriod,
                          init_state,
                          state_diff_val::Real,
                          tmax::Int=nv(graph(qwp)))
  state = evolve(qwp, init_state)
  for t=1:tmax
    if state_diff(qwp, state, init_state) &lt; state_diff_val
      return t
    end
    state = evolve(qwp, state)
  end
  return -1
end

function QWPeriod(szegedy::AbstractSzegedy)
  operators = QuantumWalk.szegedy_walk_operators(szegedy)
  parameters = Dict{Symbol,Any}(:operators =&gt; operators)
  QWPeriod(szegedy, parameters)
end</code></pre><p>According to the definition above, the following function should be implemented for <code>Model</code>:</p><ul><li><p><code>QWPeriod(model::Model,...)</code>,</p></li><li><p><code>check_dynamics(QWPeriod, model::Model, parameters::Dict{Symbol,Any})</code>,</p></li><li><p><code>evolve(qwp::QWPeriod{&lt;:Model}, state)</code>,</p></li><li><p><code>state_diff(qwp::QWPeriod{&lt;:Model}, state1::S, state2::S) where S</code>.</p></li></ul><p>Note that for <code>Szegedy</code> function <code>evolve</code> is already implemented, and we can use private function for <code>check_dynamics</code>. Furthermore <code>execute</code> family commands are inherited from <code>QWDynamics</code>, which in this case is equivalent to execution of <code>QWEvolution</code>.</p><p>The implementation for the Szegedy can have following form:</p><pre><code class="language-julia">function QWPeriod(szegedy::AbstractSzegedy)
  operators = QuantumWalk.szegedy_walk_operators(szegedy)
  parameters = Dict{Symbol,Any}(:operators =&gt; operators)
  QWPeriod(szegedy, parameters)
end

function check_qwdynamics(::Type{QWPeriod}, szegedy::AbstractSzegedy, parameters::Dict{Symbol})
  QuantumWalk.check_szegedy(szegedy, parameters)
end

function state_diff(qwp::QWPeriod{&lt;:AbstractSzegedy},
                    state1::SparseVector{T},
                    state2::SparseVector{T}) where T&lt;:Number
  1-abs(sum(state1.*conj.(state2)))
end</code></pre><p>Thanks to the code above we can check the periodicity for the <code>Szegedy</code> walk.</p><pre><code class="language-julia">julia&gt; n = 20
20

julia&gt; qwp = QWPeriod(Szegedy(barabasi_albert(n, 3)));

julia&gt; determine_period(qwp, sparse(fill(1/n, n^2)), 0.01)
1

julia&gt; state = sparse(randn(n^2)); state /= norm(state);

julia&gt; determine_period(qwp, state, 0.05, 8000)
401</code></pre><footer><hr/><a class="previous" href="szegedy.html"><span class="direction">Previous</span><span class="title">Szegedy model</span></a><a class="next" href="contributing.html"><span class="direction">Next</span><span class="title">Contributing</span></a></footer></article></body></html>
