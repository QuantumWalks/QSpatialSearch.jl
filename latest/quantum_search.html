<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum search · QuantumWalk</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/logo.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="QuantumWalk logo"/></a><h1>QuantumWalk</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="type_hierarchy.html">Type hierarchy</a></li><li><span class="toctext">Examplary dynamics</span><ul><li><a class="toctext" href="quantum_walk.html">Quantum walk evolution</a></li><li class="current"><a class="toctext" href="quantum_search.html">Quantum search</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Adjusting-model-to-QWSearch-1">Adjusting model to <code>QWSearch</code></a></li><li><a class="toctext" href="#Full-docs-1">Full docs</a></li></ul></li></ul></li><li><span class="toctext">Examplary models</span><ul><li><a class="toctext" href="ctqw.html">CTQW model</a></li><li><a class="toctext" href="szegedy.html">Szegedy model</a></li></ul></li><li><span class="toctext">How to make your own types?</span><ul><li><a class="toctext" href="new_model.html">New model</a></li><li><a class="toctext" href="new_dynamics.html">New dynamics</a></li></ul></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="citing.html">Citing</a></li><li><a class="toctext" href="license.html">Licence</a></li></ul></nav><article id="docs"><header><nav><ul><li>Examplary dynamics</li><li><a href="quantum_search.html">Quantum search</a></li></ul><a class="edit-page" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/master/docs/src/quantum_search.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Quantum search</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Quantum-Search-1" href="#Quantum-Search-1">Quantum Search</a></h1><p>Quantum spatial search is an algorithm, which starts at some initial state (which  depends on the graph structure), and runs for some time in order to cumulate  amplitude at marked vertex. The algorithm is know to outperform classical search.</p><p>The dynamics requires <code>evolve</code>, <code>measure</code>, <code>initial_state</code> and <code>check_qwdynamics</code> functions. It provides <code>execute</code>, <code>execute_single</code>, <code>execute_single_measured</code>, <code>execute_all</code> and <code>execute_all_measured</code> functions - the description can be found in <em>Quantum walk evolution</em> section. The only difference is that <code>QWSearch</code> uses the state provided by <code>initial_state</code> function, unless other is provided. Furthermore the function provides <code>marked</code>, <code>penalty</code> and <code>maximize_quantum_search</code>. While the first two simple provides the parameters typical to <code>QWSearch</code>, the last one searches for optimal measure time. The maximization depends on the model (if it is continuous or discrete). While for discrete evolution obtaining reasonable result is guaranteed, it is not the case for the continuous one, as the optimization suffers locating at local extremum.</p><p>The <code>penalty</code> is an additional time added in optimization. Note, that if we optimize  time/success_probability(time) function, the optimum is always at time 0. This would imply that algorithm achieves full efficiency if it is instantly measured. This is misleading, as the time for constructing initial state and for measurement is ignored.  Hence we need to include (usually small) additional time in <code>penalty</code> in order to  get useful result. Note the  time/success_probability(time) is at called  <em>expected_runtime</em> and can be obtained by <code>expected_runtime</code> function.</p><p>Some function as a result outputs not <code>QSearchState</code> instead of the original state.  The struct consists of the original state, the runtime and the probability of measuring  each marked vertex. Those elements can be extracted by <code>state</code>, <code>runtime</code> and <code>probability</code> functions.</p><p>Following functions are connected to the dynamics:</p><ul><li><a href="quantum_walk.html#QuantumWalk.QWEvolution"><code>QuantumWalk.QWEvolution</code></a></li><li><a href="quantum_walk.html#QuantumWalk.check_qwdynamics-Tuple{Any}"><code>QuantumWalk.check_qwdynamics</code></a></li><li><a href="quantum_walk.html#QuantumWalk.evolve-Tuple{Any}"><code>QuantumWalk.evolve</code></a></li><li><a href="quantum_walk.html#QuantumWalk.execute-Tuple{QuantumWalk.QWDynamics,Any,Real}"><code>QuantumWalk.execute</code></a></li><li><a href="quantum_walk.html#QuantumWalk.execute_all-Tuple{QuantumWalk.QWDynamics{#s16} where #s16&lt;:QuantumWalk.QWModelDiscr,Any,Int64}"><code>QuantumWalk.execute_all</code></a></li><li><a href="quantum_walk.html#QuantumWalk.execute_all_measured-Tuple{QuantumWalk.QWDynamics{#s16} where #s16&lt;:QuantumWalk.QWModelDiscr,Any,Int64}"><code>QuantumWalk.execute_all_measured</code></a></li><li><a href="quantum_walk.html#QuantumWalk.execute_single-Tuple{QuantumWalk.QWDynamics{#s16} where #s16&lt;:QuantumWalk.QWModelDiscr,Any,Int64}"><code>QuantumWalk.execute_single</code></a></li><li><a href="quantum_walk.html#QuantumWalk.execute_single_measured-Tuple{QuantumWalk.QWDynamics,Any,Real}"><code>QuantumWalk.execute_single_measured</code></a></li><li><a href="quantum_walk.html#QuantumWalk.measure-Tuple{Any}"><code>QuantumWalk.measure</code></a></li></ul><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>TODO</p><h2><a class="nav-anchor" id="Adjusting-model-to-QWSearch-1" href="#Adjusting-model-to-QWSearch-1">Adjusting model to <code>QWSearch</code></a></h2><p>TODO</p><h2><a class="nav-anchor" id="Full-docs-1" href="#Full-docs-1">Full docs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.QWSearch" href="#QuantumWalk.QWSearch"><code>QuantumWalk.QWSearch</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QWSearch(model, marked, parameters, penalty)</code></pre><p>Simulates quantum search on <code>model</code> with <code>marked</code> vertices and additional <code>parameters</code>. <code>penalty</code> represents the cost of initial state creation and measurement, which should be included for better optimization, see documentation of <code>maximizing_function</code>.</p><p>Needs implementation of</p><ul><li><p>initial_state(::QWEvolution)</p></li><li><p><code>evolve(::QWEvolution{&lt;:QWModelDiscr}, state)</code> or <code>evolve(::QWEvolution{&lt;:QWModelCont}, state, time::Real)</code></p></li><li><p><code>measure(::QWEvolution, state)</code></p></li><li><p><code>check_qwsearch(::QWModelDiscr, parameters::Dict{Symbol})</code></p></li><li><p>proper constructors.</p></li></ul><p>Offers functions</p><ul><li><p><code>execute</code></p></li><li><p><code>execute_single</code></p></li><li><p><code>execute_single_measured</code></p></li><li><p><code>execute_all</code></p></li><li><p><code>execute_all_measured</code></p></li><li><p><code>maximize_quantum_search</code></p></li><li><p><code>expected_runtime</code></p></li></ul><p>and type <code>QSearchState</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch.jl#L11-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.marked" href="#QuantumWalk.marked"><code>QuantumWalk.marked</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">marked(qss)</code></pre><p>Returns <code>marked</code> element of <code>qss</code>.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(CTQW(CompleteGraph(4)), [1])
QuantumWalk.QWSearch{QuantumWalk.CTQW,Float64}(QuantumWalk.CTQW({4, 6} undirected simple Int64 graph, :adjacency), [1], Dict{Symbol,Any}(Pair{Symbol,Any}(:hamiltonian,
  [1, 1]  =  1.0+0.0im
  [2, 1]  =  0.333333+0.0im
  [3, 1]  =  0.333333+0.0im
  [4, 1]  =  0.333333+0.0im
  [1, 2]  =  0.333333+0.0im
  [3, 2]  =  0.333333+0.0im
  [4, 2]  =  0.333333+0.0im
  [1, 3]  =  0.333333+0.0im
  [2, 3]  =  0.333333+0.0im
  [4, 3]  =  0.333333+0.0im
  [1, 4]  =  0.333333+0.0im
  [2, 4]  =  0.333333+0.0im
  [3, 4]  =  0.333333+0.0im)), 0.0)

julia&gt; marked(qss)
1-element Array{Int64,1}:
  1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch.jl#L52-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.penalty" href="#QuantumWalk.penalty"><code>QuantumWalk.penalty</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">penalty(qss)</code></pre><p>Returns <code>penalty</code> element of <code>qss</code>.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(CTQW(CompleteGraph(4)), [1])
QuantumWalk.QWSearch{QuantumWalk.CTQW,Float64}(QuantumWalk.CTQW({4, 6} undirected simple Int64 graph, :adjacency), [1], Dict{Symbol,Any}(Pair{Symbol,Any}(:hamiltonian,
  [1, 1]  =  1.0+0.0im
  [2, 1]  =  0.333333+0.0im
  [3, 1]  =  0.333333+0.0im
  [4, 1]  =  0.333333+0.0im
  [1, 2]  =  0.333333+0.0im
  [3, 2]  =  0.333333+0.0im
  [4, 2]  =  0.333333+0.0im
  [1, 3]  =  0.333333+0.0im
  [2, 3]  =  0.333333+0.0im
  [4, 3]  =  0.333333+0.0im
  [1, 4]  =  0.333333+0.0im
  [2, 4]  =  0.333333+0.0im
  [3, 4]  =  0.333333+0.0im)), 0.0)

julia&gt; penalty(qss)
0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch.jl#L81-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.check_qwdynamics" href="#QuantumWalk.check_qwdynamics"><code>QuantumWalk.check_qwdynamics</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">check_qwevolution(dynamictype, model, ..., parameters)</code></pre><p>Checks whetver combination of the arguments creates valid quantum walk dynamics. The behaviour strongly depends on arguments.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/QuantumWalk.jl#L57-L62">source</a><div><pre><code class="language-none">check_qwsearch(ctqw::AbstractCTQW, marked, parameters)</code></pre><p>Checks whetver combination of <code>ctqw</code>, <code>marked</code> and <code>parameters</code> produces valid <code>QWSearch</code> object. It checks where <code>parameters</code> consists of key <code>:hamiltonian</code> with corresponding value being <code>SparseMatrixCSC</code> or <code>Matrix</code>. Furthermore the hamiltonian needs to be square of size equals to <code>graph(ctqw)</code> order.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/ctqw/ctqw.jl#L117-L124">source</a><div><pre><code class="language-none">check_qwevolution(ctqw::AbstractCTQW, parameters)</code></pre><p>Checks whetver combination of <code>ctqw</code> and <code>parameters</code> produces valid <code>QWSearch</code> object. It checks where <code>parameters</code> consists of key <code>:hamiltonian</code> with corresponding value being <code>SparseMatrixCSC</code> or <code>Matrix</code>. Furthermore the hamiltonian needs to be square of size equals to <code>graph(ctqw)</code> order.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/ctqw/ctqw.jl#L148-L155">source</a><div><pre><code class="language-none">check_qwsearch(szegedy::AbstractSzegedy, marked, parameters)</code></pre><p>Check whetver combination of <code>szegedy</code>, <code>marked</code> and <code>parameters</code> produces valid <code>QWSearch</code> object. It checks where <code>parameters</code> consists of key <code>:operators</code> with corresponding value being list of <code>SparseMatrixCSC</code>. Furthermore operators needs to be square of size equals to square of <code>graph(szegedy).</code> order.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/szegedy/szegedy.jl#L159-L166">source</a><div><pre><code class="language-none">check_qwevolution(szegedy::AbstractSzegedy, marked, parameters)</code></pre><p>Check whetver combination of <code>szegedy</code>, <code>marked</code> and <code>parameters</code> produces a valid <code>QWEvolution</code> object. It checks where <code>parameters</code> consists of key <code>:operators</code> with corresponding value being a list of <code>SparseMatrixCSC</code> objects. Furthermore operators need to be square of size equals to square of the order of <code>graph(szegedy)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/szegedy/szegedy.jl#L174-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute-Tuple{QuantumWalk.QWSearch,Real}" href="#QuantumWalk.execute-Tuple{QuantumWalk.QWSearch,Real}"><code>QuantumWalk.execute</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute(qss,[ initstate,] runtime[, all, measure])</code></pre><p>Run proper execution  of quantum spatial search depending on given keywords. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>all</code> and <code>measure</code> keywords defaults to <code>false</code>. For detailed description please see documentation of corresponding function. Note that for <code>all</code> equal to <code>true</code> model in <code>qss</code> needs to be disrete.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch_dynamics.jl#L9-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Any,Int64}" href="#QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Any,Int64}"><code>QuantumWalk.execute_single</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_single(qss,[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>runtime</code> needs to be nonnegative. If <code>qss</code> is based on on <code>QWModelDiscr</code>, <code>runtime</code> needs to be <code>Int</code>. <code>QSearchState{S}</code>, where <code>S</code> is the state type, is returned.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_single(qss, 4)
QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.438623
  [3 ]  =  0.438623
  [4 ]  =  0.438623
  [5 ]  =  0.104937
  [7 ]  =  0.254884
  [8 ]  =  0.254884
  [9 ]  =  0.104937
  [10]  =  0.254884
  [12]  =  0.254884
  [13]  =  0.104937
  [14]  =  0.254884
  [15]  =  0.254884, [0.577169], 4)
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch_dynamics.jl#L34-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_single_measured-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Int64}" href="#QuantumWalk.execute_single_measured-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Int64}"><code>QuantumWalk.execute_single_measured</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_single_measured(qss, [ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>runtime</code> needs to be nonnegative. If <code>qss</code> is based on on <code>QWModelDiscr</code>, <code>runtime</code> needs to be <code>Int</code>. Probability measurement distribution is returned.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_single_measured(qss, 4)
4-element Array{Float64,1}:
 0.577169
 0.140944
 0.140944
 0.140944</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch_dynamics.jl#L86-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_all-Union{Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,S,Int64}, Tuple{S}} where S" href="#QuantumWalk.execute_all-Union{Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,S,Int64}, Tuple{S}} where S"><code>QuantumWalk.execute_all</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_all(qss::QSWSearch{&lt;:QWModelDiscr},[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. <code>runtime</code> needs to be nonnegative. The initial state is generated by <code>initial_state(qss)</code> function if not provided. Quantum walk model needs to be discrete. Returns list of all <code>QSearchState{S}</code> where <code>S</code> is state type including <code>initstate</code>  and last state.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_all(qss, 2)
3-element Array{QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64},1}:
 QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.288675
  [3 ]  =  0.288675
  [4 ]  =  0.288675
  [5 ]  =  0.288675
  [7 ]  =  0.288675
  [8 ]  =  0.288675
  [9 ]  =  0.288675
  [10]  =  0.288675
  [12]  =  0.288675
  [13]  =  0.288675
  [14]  =  0.288675
  [15]  =  0.288675, [0.25], 0)
 QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.481125
  [3 ]  =  0.481125
  [4 ]  =  0.481125
  [5 ]  =  -0.288675
  [7 ]  =  -0.096225
  [8 ]  =  -0.096225
  [9 ]  =  -0.288675
  [10]  =  -0.096225
  [12]  =  -0.096225
  [13]  =  -0.288675
  [14]  =  -0.096225
  [15]  =  -0.096225, [0.694444], 1)
 QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  -0.138992
  [3 ]  =  -0.138992
  [4 ]  =  -0.138992
  [5 ]  =  0.032075
  [7 ]  =  -0.395592
  [8 ]  =  -0.395592
  [9 ]  =  0.032075
  [10]  =  -0.395592
  [12]  =  -0.395592
  [13]  =  0.032075
  [14]  =  -0.395592
  [15]  =  -0.395592, [0.0579561], 2)

</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch_dynamics.jl#L110-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_all_measured-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Int64}" href="#QuantumWalk.execute_all_measured-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Int64}"><code>QuantumWalk.execute_all_measured</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_all_measured(qss::QWSearch{&lt;:QWModelDiscr},[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. <code>runtime</code> needs to be nonnegative. The initial state is generated by <code>initial_state(qss)</code> function if not provided.Quantum walk model needs to be discrete. As a result return matrix of type <code>Matrix{Float64}</code> for which <code>i</code>-th column  is measurement probability distribution in <code>i-1</code>-th step.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_all_measured(qss, 2)
4×3 Array{Float64,2}:
 0.25  0.694444  0.0579561
 0.25  0.101852  0.314015
 0.25  0.101852  0.314015
 0.25  0.101852  0.314015

</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch_dynamics.jl#L183-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.maximize_quantum_search" href="#QuantumWalk.maximize_quantum_search"><code>QuantumWalk.maximize_quantum_search</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">maximize_quantum_search(qss::QWSearch{&lt;:QWModelCont} [, maxtime, tstep])</code></pre><p>Determines optimal runtime for continuous quantum walk models. The time is searched in [0, maxtime] interval, with penalty <code>penalty(qss)</code>, which is added. It is recommended for penalty to be nonzero, otherwise time close to 0 is usually returned. Typically small <code>penalty</code> approximately equal to log(n) is enough, but optimal value may depend on the model or graph chosen.</p><p>The optimal time is chosen according to expected runtime, which equals to runtime over probability, which simulates the Bernoulli process based on <code>QWModelCont</code>.</p><p><code>tstep</code> is used for primary grid search to search for determine intervale which is supsected to have small expected runtime. To large value may miss the optimal value, while to small may greatly increase runtime of the algorithm.</p><p><code>maxtime</code> defaults to graph order n, <code>tstep</code> defaults to <code>sqrt(n)/5</code>. <code>QSearchState</code> is returned by deafult without <code>penalty</code>. Note that in general the probability is not maximal</p><pre><code class="language-">julia&gt; using QuantumWalk,LightGraphs

julia&gt; qss = QWSearch(CTQW(CompleteGraph(100)), [1], 0.01, 1.);

julia&gt; result = maximize_quantum_search(qss)
QuantumWalk.QSearchState{Array{Complex{Float64},1},Float64}(Complex{Float64}[0.621142+0.695665im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im  …  0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im], [0.869767], 12.99636940469214)

julia&gt; expected_runtime(result)
14.94235723559316

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.869767

julia&gt; probability(execute_single(qss, pi*sqrt(100)/2))
1-element Array{Float64,1}:
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/maximizing_function.jl#L4-L44">source</a><div><p>maximize_quantum_search(qss::QWSearch{&lt;:QWModelDiscr} [, runtime, mode])</p><p>Determines optimal runtime for continuous quantum walk models. The time is searched in [0, runtime] interval, with penalty <code>penalty(qss)</code>, which is added. It is recommended for penalty to be nonzero, otherwise time close 0 is returned. Typically small <code>penalty</code> approximately equal to log(n) is enough, but optimal value may depend on the model or graph chosen.</p><p>The optimal time depende on chosen <code>mode</code>:</p><ul><li><p><code>:firstmaxprob</code> stops when probability start to decrease,</p></li><li><p><code>:firstmaxeff</code> stops whene expected runtime start to increase,</p></li><li><p><code>:maxtimeeff</code> chooses exhaustively the time from [0, runtime] with smallest expected time,</p></li><li><p><code>:maxtimeprob</code> chooses exhaustively the time from [0, runtime] with maximal success probability,</p></li><li><p><code>:maxeff</code> (default) finds optimal time with smallest expected time, usually faster</p></li></ul><p>than <code>:maxtimefff</code>.</p><p>Note last three modes always returns optimal time within the interval.</p><p><code>maxtime</code> defaults to graph order n, <code>mode</code> defaults to <code>:maxeff</code>. <code>QSearchState</code> is returned by deafult without <code>penalty</code>.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(200)), [1], 1);

julia&gt; result = maximize_quantum_search(qss);

julia&gt; runtime(result)
7

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.500016

julia&gt; result = maximize_quantum_search(qss, 100, :maxtimeprob);

julia&gt; runtime(result)
40

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.550938</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/maximizing_function.jl#L90-L133">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.QSearchState" href="#QuantumWalk.QSearchState"><code>QuantumWalk.QSearchState</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QSearchState(state, probability, runtime)
QSearchState(qss, state, runtime)</code></pre><p>Creates container which consists of <code>state</code>, success probability <code>probability</code> and running time <code>runtime</code>. Validity of <code>probability</code> and <code>runtime</code> is not checked.</p><p>In second case <code>state</code> is measured according to <code>qss</code> is made.</p><pre><code class="language-julia-repl">julia?&gt; 2+2
5

julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0)
QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.288675
  [3 ]  =  0.288675
  [4 ]  =  0.288675
  [5 ]  =  0.288675
  [7 ]  =  0.288675
  [8 ]  =  0.288675
  [9 ]  =  0.288675
  [10]  =  0.288675
  [12]  =  0.288675
  [13]  =  0.288675
  [14]  =  0.288675
  [15]  =  0.288675, [0.25], 0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch.jl#L110-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.state" href="#QuantumWalk.state"><code>QuantumWalk.state</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">state(qsearchstate)</code></pre><p>Returns the state of qsearchstate.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0);

julia&gt; state(result)
16-element SparseVector{Float64,Int64} with 12 stored entries:
  [2 ]  =  0.288675
  [3 ]  =  0.288675
  [4 ]  =  0.288675
  [5 ]  =  0.288675
  [7 ]  =  0.288675
  [8 ]  =  0.288675
  [9 ]  =  0.288675
  [10]  =  0.288675
  [12]  =  0.288675
  [13]  =  0.288675
  [14]  =  0.288675
  [15]  =  0.288675</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch.jl#L156-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.probability" href="#QuantumWalk.probability"><code>QuantumWalk.probability</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">probability(qsearchstate)</code></pre><p>Returns the list of probabilities of finding marked vertices.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0);

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.25
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch.jl#L184-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.runtime" href="#QuantumWalk.runtime"><code>QuantumWalk.runtime</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">runtime(qsearchstate)</code></pre><p>Returns the time for which the state was calulated.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0);

julia&gt; runtime(result)
0
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch.jl#L202-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.expected_runtime" href="#QuantumWalk.expected_runtime"><code>QuantumWalk.expected_runtime</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">expected_runtime(runtime, probability)
expected_runtime(state)</code></pre><p>Returns the expected runtime needed for quantum walk, considering it as Bernoulli process. It equals to <code>runtime/probability</code>. In the case of <code>state</code> provided the measurement is made.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = execute(qss, 4);

julia&gt; expected_runtime(result)
6.930377097077988

julia&gt; expected_runtime(runtime(result), sum(probability(result)))
6.930377097077988</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/d9d0270fc690d382dca3a460ff3907d2e66395fc/src/qwsearch/qwsearch_util.jl#L23-L42">source</a></section><footer><hr/><a class="previous" href="quantum_walk.html"><span class="direction">Previous</span><span class="title">Quantum walk evolution</span></a><a class="next" href="ctqw.html"><span class="direction">Next</span><span class="title">CTQW model</span></a></footer></article></body></html>
