<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum search · QuantumWalk</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/logo.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="QuantumWalk logo"/></a><h1>QuantumWalk</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="type_hierarchy.html">Type hierarchies</a></li><li><span class="toctext">Dynamics</span><ul><li><a class="toctext" href="quantum_walk.html">Quantum walk evolution</a></li><li class="current"><a class="toctext" href="quantum_search.html">Quantum search</a><ul class="internal"><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#Adjusting-model-to-QWSearch-1">Adjusting model to <code>QWSearch</code></a></li><li><a class="toctext" href="#Full-docs-1">Full docs</a></li></ul></li></ul></li><li><span class="toctext">Walk models</span><ul><li><a class="toctext" href="ctqw.html">CTQW model</a></li><li><a class="toctext" href="szegedy.html">Szegedy model</a></li></ul></li><li><a class="toctext" href="new_dynamics.html">New dynamics</a></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="citing.html">Citing</a></li><li><a class="toctext" href="license.html">Licence</a></li></ul></nav><article id="docs"><header><nav><ul><li>Dynamics</li><li><a href="quantum_search.html">Quantum search</a></li></ul><a class="edit-page" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/master/docs/src/quantum_search.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Quantum search</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Quantum-Search-1" href="#Quantum-Search-1">Quantum Search</a></h1><p>Quantum spatial search is an algorithm, which starts at some initial state (which  depends on the graph structure), and runs for some time in order to cumulate  amplitude at marked vertex. The algorithm is known to outperform classical search.</p><p>The dynamics requires <code>evolve</code>, <code>measure</code>, <code>initial_state</code> and <code>check_qwdynamics</code> functions. It provides <code>execute</code>, <code>execute_single</code>, <code>execute_single_measured</code>, <code>execute_all</code> and <code>execute_all_measured</code> functions - the description can be found in <a href="quantum_walk.html">Quantum walk evolution</a> section. The only difference is that <code>QWSearch</code> uses the state generated by <code>initial_state</code> function if not provided. Furthermore the function provides <code>marked</code>, <code>penalty</code> and <code>maximize_quantum_search</code>. The first two simple provides the parameters typical to <code>QWSearch</code>. The last one searches for optimal measure time. The maximization depends on the model (if it is continuous or discrete). While for discrete evolution obtaining reasonable result is guaranteed, it is not the case for the continuous one, as the optimization suffers for locating at local extrema.</p><p>The <code>penalty</code> is an additional time added in optimization. Note, that if we optimize  time/success_probability(time) function, the optimum is always at time 0. This would imply that algorithm achieves full efficiency if it is instantly measured. This is misleading, as the time for constructing initial state and for measurement is ignored.  Hence we need to include (usually small) additional time in <code>penalty</code> in order to  get useful result. Note the  time/success_probability(time) is at called  <em>expected runtime</em> and can be obtained by <code>expected_runtime</code> function.</p><p>Some function as a result outputs <code>QSearchState</code> instead of the original state.  It consists of the original state, the runtime and the probability of measuring  each marked vertex. Those elements can be extracted by <code>state</code>, <code>runtime</code> and <code>probability</code> functions.</p><p>Following functions are connected to the quantum search:</p><ul><li><a href="quantum_search.html#QuantumWalk.QSearchState"><code>QuantumWalk.QSearchState</code></a></li><li><a href="quantum_search.html#QuantumWalk.QWSearch"><code>QuantumWalk.QWSearch</code></a></li><li><a href="quantum_search.html#QuantumWalk.check_qwdynamics-Tuple{QuantumWalk.QWSearch,Array{Int64,1},Dict{Symbol,V} where V}"><code>QuantumWalk.check_qwdynamics</code></a></li><li><a href="quantum_search.html#QuantumWalk.execute-Tuple{QuantumWalk.QWSearch,Real}"><code>QuantumWalk.execute</code></a></li><li><a href="quantum_search.html#QuantumWalk.execute_all-Union{Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,S,Int64}, Tuple{S}} where S"><code>QuantumWalk.execute_all</code></a></li><li><a href="quantum_search.html#QuantumWalk.execute_all_measured-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Int64}"><code>QuantumWalk.execute_all_measured</code></a></li><li><a href="quantum_search.html#QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Any,Int64}"><code>QuantumWalk.execute_single</code></a></li><li><a href="quantum_search.html#QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch,Real}"><code>QuantumWalk.execute_single</code></a></li><li><a href="quantum_search.html#QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelCont,Any,Real}"><code>QuantumWalk.execute_single</code></a></li><li><a href="quantum_search.html#QuantumWalk.execute_single_measured-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Int64}"><code>QuantumWalk.execute_single_measured</code></a></li><li><a href="quantum_search.html#QuantumWalk.expected_runtime"><code>QuantumWalk.expected_runtime</code></a></li><li><a href="quantum_search.html#QuantumWalk.initial_state-Tuple{QuantumWalk.QWSearch}"><code>QuantumWalk.initial_state</code></a></li><li><a href="quantum_search.html#QuantumWalk.marked-Tuple{QuantumWalk.QWSearch}"><code>QuantumWalk.marked</code></a></li><li><a href="quantum_search.html#QuantumWalk.maximize_quantum_search-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr}"><code>QuantumWalk.maximize_quantum_search</code></a></li><li><a href="quantum_search.html#QuantumWalk.maximize_quantum_search-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelCont}"><code>QuantumWalk.maximize_quantum_search</code></a></li><li><a href="quantum_search.html#QuantumWalk.penalty-Tuple{QuantumWalk.QWSearch}"><code>QuantumWalk.penalty</code></a></li><li><a href="quantum_search.html#QuantumWalk.probability"><code>QuantumWalk.probability</code></a></li><li><a href="quantum_search.html#QuantumWalk.runtime"><code>QuantumWalk.runtime</code></a></li><li><a href="quantum_search.html#QuantumWalk.state"><code>QuantumWalk.state</code></a></li></ul><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><pre><code class="language-julia">julia&gt; n = 100;

julia&gt; penalty_szegedy = log(n);

julia&gt; qsearch = QWSearch(Szegedy(CompleteGraph(n)), [1], penalty_szegedy);

julia&gt; runtime(maximize_quantum_search(qsearch))-penalty_szegedy
5.0

julia&gt; probability(maximize_quantum_search(qsearch))
1-element Array{Float64,1}:
 0.569689

julia&gt; execute_single_measured(qsearch, ceil(Int, pi*sqrt(100)/2))
100-element Array{Float64,1}:
 0.428475  
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 ⋮         
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298
 0.00577298</code></pre><h2><a class="nav-anchor" id="Adjusting-model-to-QWSearch-1" href="#Adjusting-model-to-QWSearch-1">Adjusting model to <code>QWSearch</code></a></h2><p>Here we consider the example from the <a href="quantum_walk.html">Quantum walk evolution</a> section. We can consider random walk search as follows: at given step we check if we are at the marked vertex. If not, we continue evolution. Hence we need to cumulate the success probability at marked vertices. We can propose following implementation (including the functions from mentioned section). Again some additional assertion could be included for full funcionality.</p><pre><code class="language-julia">##
function check_qwdynamics(::Type{QWSearch},
                          abs_stoch::UniformStochastic,
                          ::Array{Int},
                          parameters::Dict{Symbol,Any})
  @assert :stochastic ∈ keys(parameters) &quot;parameters needs to have key stochastic&quot;
  n = nv(graph(abs_stoch))
  @assert isa(parameters[:stochastic], SparseMatrixCSC{&lt;:Real}) &quot;value for :stochastic needs to be sparse matrix with real numbers&quot;
  @assert size(parameters[:stochastic], 1) == size(parameters[:stochastic], 2) &quot;Stochastic matrix needs to be square stochastic matrix&quot;
  @assert mapslices(sum, parameters[:stochastic], 1)[1,:] ≈ ones(n) &quot;Stochastic matrix needs to be square stochastic matrix of order graph&quot;
end

function QWSearch(stoch::AbstractStochastic,
                  marked::Array{Int},
                  penalty::Real = 0.)
   parameters = Dict{Symbol,Any}(:stochastic =&gt; stochastic_matrix(graph(stoch)))

   QWSearch(stoch, marked, parameters, penalty)
end

function initial_state(qss::QWSearch{&lt;:AbstractStochastic})
  n = nv(graph(qss))
  fill(1./n, n)
end

function evolve(qss::QWSearch{&lt;:AbstractStochastic}, state::Vector{&lt;:Real})
  old_probability = measure(qss, state, marked(qss))
  state[marked(qss)] = zero(marked(qss))
  state = stochastic_evolution(parameters(qss)[:stochastic], state)
  state[marked(qss)] += old_probability
  state
end</code></pre><p>Note that for example <code>measure</code> function does not change. Below we provide an evolution simulation example.</p><pre><code class="language-julia">julia&gt; dynamic = QWSearch(UniformStochastic(CompleteGraph(100)), [1])
QuantumWalk.QWSearch{UniformStochastic{LightGraphs.SimpleGraphs.SimpleGraph{Int64}},Float64}(UniformStochastic{LightGraphs.SimpleGraphs.SimpleGraph{Int64}}({100, 4950} undirected simple Int64 graph), [1], Dict{Symbol,Any}(Pair{Symbol,Any}(:stochastic,
  [2  ,   1]  =  0.010101
  [3  ,   1]  =  0.010101
  [4  ,   1]  =  0.010101
  [5  ,   1]  =  0.010101
  [6  ,   1]  =  0.010101
  ⋮
  [94 , 100]  =  0.010101
  [95 , 100]  =  0.010101
  [96 , 100]  =  0.010101
  [97 , 100]  =  0.010101
  [98 , 100]  =  0.010101
  [99 , 100]  =  0.010101)), 0.0)

julia&gt; measure(dynamic, execute_single(dynamic, 0), [1])
1-element Array{Float64,1}:
 0.01

julia&gt; measure(dynamic, execute_single(dynamic, 40), [1])
1-element Array{Float64,1}:
 0.340416

julia&gt; measure(dynamic, execute_single(dynamic, 1000), [1])
1-element Array{Float64,1}:
 0.999961</code></pre><h2><a class="nav-anchor" id="Full-docs-1" href="#Full-docs-1">Full docs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.QWSearch" href="#QuantumWalk.QWSearch"><code>QuantumWalk.QWSearch</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QWSearch(model, marked, parameters, penalty)</code></pre><p>Simulates quantum search on <code>model</code> with <code>marked</code> vertices and additional <code>parameters</code>. <code>penalty</code> represents the cost of initial state creation and measurement, which should be included for better optimization, see documentation of <code>maximizing_function</code>.</p><p>Needs implementation of</p><ul><li><p><code>initial_state(::QWSearch)</code></p></li><li><p><code>evolve(::QWSearch{&lt;:QWModelDiscr}, state)</code> or <code>evolve(::QWEvolution{&lt;:QWModelCont}, state, time::Real)</code></p></li><li><p><code>measure(::QWSearch, state)</code></p></li><li><p><code>check_qwdynamics(::QWSearch, parameters::Dict{Symbol})</code></p></li><li><p>proper constructors.</p></li></ul><p>Offers functions</p><ul><li><p><code>execute</code></p></li><li><p><code>execute_single</code></p></li><li><p><code>execute_single_measured</code></p></li><li><p><code>execute_all</code></p></li><li><p><code>execute_all_measured</code></p></li><li><p><code>maximize_quantum_search</code></p></li><li><p><code>expected_runtime</code></p></li></ul><p>and type <code>QSearchState</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch.jl#L11-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.marked-Tuple{QuantumWalk.QWSearch}" href="#QuantumWalk.marked-Tuple{QuantumWalk.QWSearch}"><code>QuantumWalk.marked</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">marked(qss)</code></pre><p>Returns <code>marked</code> element of <code>qss</code>.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(CTQW(CompleteGraph(4)), [1]);

julia&gt; marked(qss)
1-element Array{Int64,1}:
 1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch.jl#L52-L64">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.penalty-Tuple{QuantumWalk.QWSearch}" href="#QuantumWalk.penalty-Tuple{QuantumWalk.QWSearch}"><code>QuantumWalk.penalty</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">penalty(qss)</code></pre><p>Returns <code>penalty</code> element of <code>qss</code>.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(CTQW(CompleteGraph(4)), [1]);

julia&gt; penalty(qss)
0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch.jl#L67-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.check_qwdynamics-Tuple{QuantumWalk.QWSearch,Array{Int64,1},Dict{Symbol,V} where V}" href="#QuantumWalk.check_qwdynamics-Tuple{QuantumWalk.QWSearch,Array{Int64,1},Dict{Symbol,V} where V}"><code>QuantumWalk.check_qwdynamics</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">check_qwdynamics(model, marked, parameters)</code></pre><p>Checks whetver combination of <code>model</code>, <code>marked</code> and <code>parameters</code> creates valid quantum search evolution. Note that whetver list of vertices <code>marked</code> are a subset of vertices of <code>graph</code> from <code>model</code> is checked seperately in <code>QWSearch</code> constructor.</p><p>Details concerning implementing <code>check_qwdynamics</code> for own models can be found in GitHub pages.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch.jl#L194-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute-Tuple{QuantumWalk.QWSearch,Real}" href="#QuantumWalk.execute-Tuple{QuantumWalk.QWSearch,Real}"><code>QuantumWalk.execute</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute(qss,[ initstate,] runtime[, all, measure])</code></pre><p>Run proper execution  of quantum spatial search depending on given keywords. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>all</code> and <code>measure</code> keywords defaults to <code>false</code>. For detailed description please see documentation of corresponding function. Note that for <code>all</code> equal to <code>true</code> model in <code>qss</code> needs to be disrete.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch_dynamics.jl#L9-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Any,Int64}" href="#QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Any,Int64}"><code>QuantumWalk.execute_single</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_single(qss,[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>runtime</code> needs to be nonnegative. If <code>qss</code> is based on on <code>QWModelDiscr</code>, <code>runtime</code> needs to be <code>Int</code>. <code>QSearchState{S}</code>, where <code>S</code> is the state type, is returned.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_single(qss, 4)
QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.438623
  [3 ]  =  0.438623
  [4 ]  =  0.438623
  [5 ]  =  0.104937
  [7 ]  =  0.254884
  [8 ]  =  0.254884
  [9 ]  =  0.104937
  [10]  =  0.254884
  [12]  =  0.254884
  [13]  =  0.104937
  [14]  =  0.254884
  [15]  =  0.254884, [0.577169], 4)
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch_dynamics.jl#L34-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelCont,Any,Real}" href="#QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelCont,Any,Real}"><code>QuantumWalk.execute_single</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_single(qss,[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>runtime</code> needs to be nonnegative. If <code>qss</code> is based on on <code>QWModelDiscr</code>, <code>runtime</code> needs to be <code>Int</code>. <code>QSearchState{S}</code>, where <code>S</code> is the state type, is returned.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_single(qss, 4)
QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.438623
  [3 ]  =  0.438623
  [4 ]  =  0.438623
  [5 ]  =  0.104937
  [7 ]  =  0.254884
  [8 ]  =  0.254884
  [9 ]  =  0.104937
  [10]  =  0.254884
  [12]  =  0.254884
  [13]  =  0.104937
  [14]  =  0.254884
  [15]  =  0.254884, [0.577169], 4)
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch_dynamics.jl#L34-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch,Real}" href="#QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch,Real}"><code>QuantumWalk.execute_single</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_single(qss,[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>runtime</code> needs to be nonnegative. If <code>qss</code> is based on on <code>QWModelDiscr</code>, <code>runtime</code> needs to be <code>Int</code>. <code>QSearchState{S}</code>, where <code>S</code> is the state type, is returned.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_single(qss, 4)
QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.438623
  [3 ]  =  0.438623
  [4 ]  =  0.438623
  [5 ]  =  0.104937
  [7 ]  =  0.254884
  [8 ]  =  0.254884
  [9 ]  =  0.104937
  [10]  =  0.254884
  [12]  =  0.254884
  [13]  =  0.104937
  [14]  =  0.254884
  [15]  =  0.254884, [0.577169], 4)
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch_dynamics.jl#L34-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_single_measured-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Int64}" href="#QuantumWalk.execute_single_measured-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Int64}"><code>QuantumWalk.execute_single_measured</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_single_measured(qss, [ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>runtime</code> needs to be nonnegative. If <code>qss</code> is based on on <code>QWModelDiscr</code>, <code>runtime</code> needs to be <code>Int</code>. Probability measurement distribution is returned.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_single_measured(qss, 4)
4-element Array{Float64,1}:
 0.577169
 0.140944
 0.140944
 0.140944</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch_dynamics.jl#L86-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_all-Union{Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,S,Int64}, Tuple{S}} where S" href="#QuantumWalk.execute_all-Union{Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,S,Int64}, Tuple{S}} where S"><code>QuantumWalk.execute_all</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_all(qss::QSWSearch{&lt;:QWModelDiscr},[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. <code>runtime</code> needs to be nonnegative. The initial state is generated by <code>initial_state(qss)</code> function if not provided. Quantum walk model needs to be discrete. Returns list of all <code>QSearchState{S}</code> where <code>S</code> is state type including <code>initstate</code>  and last state.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_all(qss, 2)
3-element Array{QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64},1}:
 QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.288675
  [3 ]  =  0.288675
  [4 ]  =  0.288675
  [5 ]  =  0.288675
  [7 ]  =  0.288675
  [8 ]  =  0.288675
  [9 ]  =  0.288675
  [10]  =  0.288675
  [12]  =  0.288675
  [13]  =  0.288675
  [14]  =  0.288675
  [15]  =  0.288675, [0.25], 0)
 QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.481125
  [3 ]  =  0.481125
  [4 ]  =  0.481125
  [5 ]  =  -0.288675
  [7 ]  =  -0.096225
  [8 ]  =  -0.096225
  [9 ]  =  -0.288675
  [10]  =  -0.096225
  [12]  =  -0.096225
  [13]  =  -0.288675
  [14]  =  -0.096225
  [15]  =  -0.096225, [0.694444], 1)
 QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  -0.138992
  [3 ]  =  -0.138992
  [4 ]  =  -0.138992
  [5 ]  =  0.032075
  [7 ]  =  -0.395592
  [8 ]  =  -0.395592
  [9 ]  =  0.032075
  [10]  =  -0.395592
  [12]  =  -0.395592
  [13]  =  0.032075
  [14]  =  -0.395592
  [15]  =  -0.395592, [0.0579561], 2)

</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch_dynamics.jl#L110-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_all_measured-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Int64}" href="#QuantumWalk.execute_all_measured-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr,Int64}"><code>QuantumWalk.execute_all_measured</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_all_measured(qss::QWSearch{&lt;:QWModelDiscr},[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. <code>runtime</code> needs to be nonnegative. The initial state is generated by <code>initial_state(qss)</code> function if not provided.Quantum walk model needs to be discrete. As a result return matrix of type <code>Matrix{Float64}</code> for which <code>i</code>-th column  is measurement probability distribution in <code>i-1</code>-th step.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_all_measured(qss, 2)
4×3 Array{Float64,2}:
 0.25  0.694444  0.0579561
 0.25  0.101852  0.314015
 0.25  0.101852  0.314015
 0.25  0.101852  0.314015

</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch_dynamics.jl#L183-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.initial_state-Tuple{QuantumWalk.QWSearch}" href="#QuantumWalk.initial_state-Tuple{QuantumWalk.QWSearch}"><code>QuantumWalk.initial_state</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">initial_state(qss)</code></pre><p>Generates initial state for QWSearch <code>qss</code>. The type and value strongly depends on model of <code>qss</code>. For concrete <code>model</code> description please type <code>?initial_state(QWSearch{model})</code>, for example for <code>CTQW</code> write <code>?initial_state(QWSearch{CTQW})</code>.</p><p>Details concerning implementing <code>initial_state</code> for own models can be found in GitHub pages.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch.jl#L205-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.maximize_quantum_search-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelCont}" href="#QuantumWalk.maximize_quantum_search-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelCont}"><code>QuantumWalk.maximize_quantum_search</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">maximize_quantum_search(qss::QWSearch{&lt;:QWModelCont} [, maxtime, tstep])</code></pre><p>Determines optimal runtime for continuous quantum walk models. The time is searched in [0, maxtime] interval, with penalty <code>penalty(qss)</code>, which is added. It is recommended for penalty to be nonzero, otherwise time close to 0 is usually returned. Typically small <code>penalty</code> approximately equal to log(n) is enough, but optimal value may depend on the model or graph chosen.</p><p>The optimal time is chosen according to expected runtime, which equals to runtime over probability, which simulates the Bernoulli process based on <code>QWModelCont</code>.</p><p><code>tstep</code> is used for primary grid search to search for determine intervale which is supsected to have small expected runtime. To large value may miss the optimal value, while to small may greatly increase runtime of the algorithm.</p><p><code>maxtime</code> defaults to graph order n, <code>tstep</code> defaults to <code>sqrt(n)/5</code>. <code>QSearchState</code> is returned by deafult without <code>penalty</code>. Note that in general the probability is not maximal.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(CTQW(CompleteGraph(100)), [1], 0.01, 1.);

julia&gt; result = maximize_quantum_search(qss)
QuantumWalk.QSearchState{Array{Complex{Float64},1},Float64}(Complex{Float64}[0.621142+0.695665im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im  …  0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im], [0.869767], 12.99636940469214)

julia&gt; expected_runtime(result)
14.94235723559316

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.869767

julia&gt; probability(execute_single(qss, pi*sqrt(100)/2))
1-element Array{Float64,1}:
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/maximizing_function.jl#L4-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.maximize_quantum_search-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr}" href="#QuantumWalk.maximize_quantum_search-Tuple{QuantumWalk.QWSearch{#s16,W} where W&lt;:Real where #s16&lt;:QuantumWalk.QWModelDiscr}"><code>QuantumWalk.maximize_quantum_search</code></a> — <span class="docstring-category">Method</span>.</div><div><p>maximize_quantum_search(qss::QWSearch{&lt;:QWModelDiscr} [, runtime, mode])</p><p>Determines optimal runtime for continuous quantum walk models. The time is searched in [0, runtime] interval, with penalty <code>penalty(qss)</code>, which is added. It is recommended for penalty to be nonzero, otherwise time close 0 is returned. Typically small <code>penalty</code> approximately equal to log(n) is enough, but optimal value may depend on the model or graph chosen.</p><p>The optimal time depende on chosen <code>mode</code>:</p><ul><li><p><code>:firstmaxprob</code> stops when probability start to decrease,</p></li><li><p><code>:firstmaxeff</code> stops whene expected runtime start to increase,</p></li><li><p><code>:maxtimeeff</code> chooses exhaustively the time from [0, runtime] with smallest expected time,</p></li><li><p><code>:maxtimeprob</code> chooses exhaustively the time from [0, runtime] with maximal success probability,</p></li><li><p><code>:maxeff</code> (default) finds optimal time with smallest expected time, usually faster than <code>:maxtimefff</code>.</p></li></ul><p>Note last three modes always returns optimal time within the interval.</p><p><code>maxtime</code> defaults to graph order n, <code>mode</code> defaults to <code>:maxeff</code>. <code>QSearchState</code> is returned by deafult without <code>penalty</code>.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(200)), [1], 1);

julia&gt; result = maximize_quantum_search(qss);

julia&gt; runtime(result)
7

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.500016

julia&gt; result = maximize_quantum_search(qss, 100, :maxtimeprob);

julia&gt; runtime(result)
40

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.550938</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/maximizing_function.jl#L88-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.QSearchState" href="#QuantumWalk.QSearchState"><code>QuantumWalk.QSearchState</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QSearchState(state, probability, runtime)
QSearchState(qss, state, runtime)</code></pre><p>Creates container which consists of <code>state</code>, success probability <code>probability</code> and running time <code>runtime</code>. Validity of <code>probability</code> and <code>runtime</code> is not checked.</p><p>In second case <code>state</code> is measured according to <code>qss</code> is made.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0)
QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.288675
  [3 ]  =  0.288675
  [4 ]  =  0.288675
  [5 ]  =  0.288675
  [7 ]  =  0.288675
  [8 ]  =  0.288675
  [9 ]  =  0.288675
  [10]  =  0.288675
  [12]  =  0.288675
  [13]  =  0.288675
  [14]  =  0.288675
  [15]  =  0.288675, [0.25], 0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch.jl#L82-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.state" href="#QuantumWalk.state"><code>QuantumWalk.state</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">state(qsearchstate)</code></pre><p>Returns the state of qsearchstate.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0);

julia&gt; state(result)
16-element SparseVector{Float64,Int64} with 12 stored entries:
  [2 ]  =  0.288675
  [3 ]  =  0.288675
  [4 ]  =  0.288675
  [5 ]  =  0.288675
  [7 ]  =  0.288675
  [8 ]  =  0.288675
  [9 ]  =  0.288675
  [10]  =  0.288675
  [12]  =  0.288675
  [13]  =  0.288675
  [14]  =  0.288675
  [15]  =  0.288675</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch.jl#L129-L154">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.probability" href="#QuantumWalk.probability"><code>QuantumWalk.probability</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">probability(qsearchstate)</code></pre><p>Returns the list of probabilities of finding marked vertices.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0);

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.25
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch.jl#L157-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.runtime" href="#QuantumWalk.runtime"><code>QuantumWalk.runtime</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">runtime(qsearchstate)</code></pre><p>Returns the time for which the state was calulated.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0);

julia&gt; runtime(result)
0
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch.jl#L175-L189">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.expected_runtime" href="#QuantumWalk.expected_runtime"><code>QuantumWalk.expected_runtime</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">expected_runtime(runtime, probability)
expected_runtime(state)</code></pre><p>Returns the expected runtime needed for quantum walk, considering it as Bernoulli process. It equals to <code>runtime/probability</code>. In the case of <code>state</code> provided the measurement is made.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = execute(qss, 4);

julia&gt; expected_runtime(result)
6.930377097077988

julia&gt; expected_runtime(runtime(result), sum(probability(result)))
6.930377097077988</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/2da440c495d3ad8cdf89d74c12cda8499a26e105/src/qwsearch/qwsearch_util.jl#L23-L42">source</a></section><footer><hr/><a class="previous" href="quantum_walk.html"><span class="direction">Previous</span><span class="title">Quantum walk evolution</span></a><a class="next" href="ctqw.html"><span class="direction">Next</span><span class="title">CTQW model</span></a></footer></article></body></html>
