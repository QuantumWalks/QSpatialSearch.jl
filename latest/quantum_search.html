<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum search · QuantumWalk</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/logo.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="QuantumWalk logo"/></a><h1>QuantumWalk</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="type_hierarchy.html">Type hierarchy</a></li><li><span class="toctext">Exemplary dynamics</span><ul><li><a class="toctext" href="quantum_walk.html">Quantum walk simulator</a></li><li class="current"><a class="toctext" href="quantum_search.html">Quantum search</a><ul class="internal"><li><a class="toctext" href="#Full-docs-1">Full docs</a></li></ul></li></ul></li><li><span class="toctext">Examplary models</span><ul><li><a class="toctext" href="ctqw.html">CTQW model</a></li><li><a class="toctext" href="szegedy.html">Szegedy model</a></li></ul></li><li><span class="toctext">How to make your own types?</span><ul><li><a class="toctext" href="new_model.html">New model</a></li><li><a class="toctext" href="new_dynamics.html">New dynamics</a></li></ul></li><li><a class="toctext" href="license.html">Licence</a></li></ul></nav><article id="docs"><header><nav><ul><li>Exemplary dynamics</li><li><a href="quantum_search.html">Quantum search</a></li></ul><a class="edit-page" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/master/docs/src/quantum_search.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Quantum search</span><a class="fa fa-bars" href="#"></a></div></header><ul><li><a href="quantum_walk.html#Quantum-Search-1">Quantum Search</a></li><ul><li><a href="quantum_walk.html#Full-docs-1">Full docs</a></li><ul><li><a href="quantum_walk.html#Types-and-its-function-1">Types and its function</a></li></ul></ul><li><a href="ctqw.html#Continuous-Time-Quantum-Walk-1">Continuous-Time Quantum Walk</a></li><ul><li><a href="ctqw.html#Full-docs-1">Full docs</a></li><ul><li><a href="ctqw.html#Model-definition-1">Model definition</a></li><li><a href="ctqw.html#General-model-functions-1">General model functions</a></li><li><a href="ctqw.html#QWSearch-documentation-1">QWSearch documentation</a></li><li><a href="ctqw.html#QWEvolution-documentation-1">QWEvolution documentation</a></li></ul></ul><li><a href="szegedy.html#Szegedy-Quantum-Walk-1">Szegedy Quantum Walk</a></li><ul><li><a href="szegedy.html#Full-docs-1">Full docs</a></li><li><a href="szegedy.html#Model-definition-1">Model definition</a></li><ul><li><a href="szegedy.html#General-model-functions-1">General model functions</a></li><li><a href="szegedy.html#Quantum-search-constructor-1">Quantum search constructor</a></li><li><a href="szegedy.html#Quantum-walk-constructor-1">Quantum walk constructor</a></li></ul></ul><li><a href="quantum_search.html#Quantum-Search-1">Quantum Search</a></li><ul><li><a href="quantum_search.html#Full-docs-1">Full docs</a></li><ul><li><a href="quantum_search.html#Types-and-its-function-1">Types and its function</a></li><li><a href="quantum_search.html#QSearchState-1">QSearchState</a></li></ul></ul><li><a href="type_hierarchy.html#Quantum-Walk-models-1">Quantum Walk models</a></li><ul><li><a href="type_hierarchy.html#Full-docs-1">Full docs</a></li><ul><li><a href="type_hierarchy.html#Types-and-its-function-1">Types and its function</a></li></ul></ul><li><a href="type_hierarchy.html#Quantum-Dynamics-1">Quantum Dynamics</a></li><ul><li><a href="type_hierarchy.html#Full-docs-2">Full docs</a></li><ul><li><a href="type_hierarchy.html#Types-and-its-function-2">Types and its function</a></li><li><a href="type_hierarchy.html#Functions-1">Functions</a></li></ul></ul></ul><h1><a class="nav-anchor" id="Quantum-Search-1" href="#Quantum-Search-1">Quantum Search</a></h1><h2><a class="nav-anchor" id="Full-docs-1" href="#Full-docs-1">Full docs</a></h2><h3><a class="nav-anchor" id="Types-and-its-function-1" href="#Types-and-its-function-1">Types and its function</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.QWSearch" href="#QuantumWalk.QWSearch"><code>QuantumWalk.QWSearch</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QWSearch(model, marked, parameters, penalty)</code></pre><p>Simulates quantum search on <code>model</code> with <code>marked</code> vertices and additional <code>parameters</code>. <code>penalty</code> represents the cost of initial state creation and measurement, which should be included for better optimization, see documentation of <code>maximizing_function</code>.</p><p>Needs implementation of</p><ul><li><p>initial_state(::QWEvolution)</p></li><li><p><code>evolve(::QWEvolution{&lt;:QWModelDiscr}, state)</code> or <code>evolve(::QWEvolution{&lt;:QWModelCont}, state, time::Real)</code></p></li><li><p><code>measure(::QWEvolution, state)</code></p></li><li><p><code>check_qwsearch(::QWModelDiscr, parameters::Dict{Symbol})</code></p></li><li><p>proper constructors.</p></li></ul><p>Offers functions</p><ul><li><p><code>execute</code></p></li><li><p><code>execute_single</code></p></li><li><p><code>execute_single_measured</code></p></li><li><p><code>execute_all</code></p></li><li><p><code>execute_all_measured</code></p></li><li><p><code>maximize_quantum_search</code></p></li><li><p><code>expected_runtime</code></p></li></ul><p>and type <code>QSearchState</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch.jl#L11-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.marked" href="#QuantumWalk.marked"><code>QuantumWalk.marked</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">marked(qss)</code></pre><p>Returns <code>marked</code> element of <code>qss</code>.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(CTQW(CompleteGraph(4)), [1])
QuantumWalk.QWSearch{QuantumWalk.CTQW,Float64}(QuantumWalk.CTQW({4, 6} undirected simple Int64 graph, :adjacency), [1], Dict{Symbol,Any}(Pair{Symbol,Any}(:hamiltonian,
  [1, 1]  =  1.0+0.0im
  [2, 1]  =  0.333333+0.0im
  [3, 1]  =  0.333333+0.0im
  [4, 1]  =  0.333333+0.0im
  [1, 2]  =  0.333333+0.0im
  [3, 2]  =  0.333333+0.0im
  [4, 2]  =  0.333333+0.0im
  [1, 3]  =  0.333333+0.0im
  [2, 3]  =  0.333333+0.0im
  [4, 3]  =  0.333333+0.0im
  [1, 4]  =  0.333333+0.0im
  [2, 4]  =  0.333333+0.0im
  [3, 4]  =  0.333333+0.0im)), 0.0)

julia&gt; marked(qss)
1-element Array{Int64,1}:
  1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch.jl#L52-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.penalty" href="#QuantumWalk.penalty"><code>QuantumWalk.penalty</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">penalty(qss)</code></pre><p>Returns <code>penalty</code> element of <code>qss</code>.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(CTQW(CompleteGraph(4)), [1])
QuantumWalk.QWSearch{QuantumWalk.CTQW,Float64}(QuantumWalk.CTQW({4, 6} undirected simple Int64 graph, :adjacency), [1], Dict{Symbol,Any}(Pair{Symbol,Any}(:hamiltonian,
  [1, 1]  =  1.0+0.0im
  [2, 1]  =  0.333333+0.0im
  [3, 1]  =  0.333333+0.0im
  [4, 1]  =  0.333333+0.0im
  [1, 2]  =  0.333333+0.0im
  [3, 2]  =  0.333333+0.0im
  [4, 2]  =  0.333333+0.0im
  [1, 3]  =  0.333333+0.0im
  [2, 3]  =  0.333333+0.0im
  [4, 3]  =  0.333333+0.0im
  [1, 4]  =  0.333333+0.0im
  [2, 4]  =  0.333333+0.0im
  [3, 4]  =  0.333333+0.0im)), 0.0)

julia&gt; penalty(qss)
0.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch.jl#L81-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.check_qwsearch" href="#QuantumWalk.check_qwsearch"><code>QuantumWalk.check_qwsearch</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">check_qwsearch(model, marked, parameters)</code></pre><p>Checks whetver combination of <code>model</code>, <code>marked</code> and <code>parameters</code> creates valid quantum search evolution. Note that whetver list of vertices <code>marked</code> are a subset of vertices of <code>graph</code> from <code>model</code> is checked seperately in <code>QWSearch</code> constructor.</p><p>Details concerning implementing <code>check_qwsearch</code> for own models can be found in GitHub pages.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch.jl#L221-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute-Tuple{QuantumWalk.QWSearch,Real}" href="#QuantumWalk.execute-Tuple{QuantumWalk.QWSearch,Real}"><code>QuantumWalk.execute</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute(qss,[ initstate,] runtime[, all, measure])</code></pre><p>Run proper execution  of quantum spatial search depending on given keywords. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>all</code> and <code>measure</code> keywords defaults to <code>false</code>. For detailed description please see documentation of corresponding function. Note that for <code>all</code> equal to <code>true</code> model in <code>qss</code> needs to be disrete.</p></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch_dynamics.jl#L9-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch{#s10,W} where W&lt;:Real where #s10&lt;:QuantumWalk.QWModelDiscr,Any,Int64}" href="#QuantumWalk.execute_single-Tuple{QuantumWalk.QWSearch{#s10,W} where W&lt;:Real where #s10&lt;:QuantumWalk.QWModelDiscr,Any,Int64}"><code>QuantumWalk.execute_single</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_single(qss,[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>runtime</code> needs to be nonnegative. If <code>qss</code> is based on on <code>QWModelDiscr</code>, <code>runtime</code> needs to be <code>Int</code>. <code>QSearchState{S}</code>, where <code>S</code> is the state type, is returned.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_single(qss, 4)
QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.438623
  [3 ]  =  0.438623
  [4 ]  =  0.438623
  [5 ]  =  0.104937
  [7 ]  =  0.254884
  [8 ]  =  0.254884
  [9 ]  =  0.104937
  [10]  =  0.254884
  [12]  =  0.254884
  [13]  =  0.104937
  [14]  =  0.254884
  [15]  =  0.254884, [0.577169], 4)
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch_dynamics.jl#L34-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_single_measured-Tuple{QuantumWalk.QWSearch{#s10,W} where W&lt;:Real where #s10&lt;:QuantumWalk.QWModelDiscr,Int64}" href="#QuantumWalk.execute_single_measured-Tuple{QuantumWalk.QWSearch{#s10,W} where W&lt;:Real where #s10&lt;:QuantumWalk.QWModelDiscr,Int64}"><code>QuantumWalk.execute_single_measured</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_single_measured(qss, [ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. The initial state is generated by <code>initial_state(qss)</code> function if not provided. <code>runtime</code> needs to be nonnegative. If <code>qss</code> is based on on <code>QWModelDiscr</code>, <code>runtime</code> needs to be <code>Int</code>. Probability measurement distribution is returned.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_single_measured(qss, 4)
4-element Array{Float64,1}:
 0.577169
 0.140944
 0.140944
 0.140944</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch_dynamics.jl#L86-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_all-Union{Tuple{QuantumWalk.QWSearch{#s10,W} where W&lt;:Real where #s10&lt;:QuantumWalk.QWModelDiscr,S,Int64}, Tuple{S}} where S" href="#QuantumWalk.execute_all-Union{Tuple{QuantumWalk.QWSearch{#s10,W} where W&lt;:Real where #s10&lt;:QuantumWalk.QWModelDiscr,S,Int64}, Tuple{S}} where S"><code>QuantumWalk.execute_all</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_all(qss::QSWSearch{&lt;:QWModelDiscr},[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. <code>runtime</code> needs to be nonnegative. The initial state is generated by <code>initial_state(qss)</code> function if not provided. Quantum walk model needs to be discrete. Returns list of all <code>QSearchState{S}</code> where <code>S</code> is state type including <code>initstate</code>  and last state.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_all(qss, 2)
3-element Array{QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64},1}:
 QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.288675
  [3 ]  =  0.288675
  [4 ]  =  0.288675
  [5 ]  =  0.288675
  [7 ]  =  0.288675
  [8 ]  =  0.288675
  [9 ]  =  0.288675
  [10]  =  0.288675
  [12]  =  0.288675
  [13]  =  0.288675
  [14]  =  0.288675
  [15]  =  0.288675, [0.25], 0)
 QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.481125
  [3 ]  =  0.481125
  [4 ]  =  0.481125
  [5 ]  =  -0.288675
  [7 ]  =  -0.096225
  [8 ]  =  -0.096225
  [9 ]  =  -0.288675
  [10]  =  -0.096225
  [12]  =  -0.096225
  [13]  =  -0.288675
  [14]  =  -0.096225
  [15]  =  -0.096225, [0.694444], 1)
 QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  -0.138992
  [3 ]  =  -0.138992
  [4 ]  =  -0.138992
  [5 ]  =  0.032075
  [7 ]  =  -0.395592
  [8 ]  =  -0.395592
  [9 ]  =  0.032075
  [10]  =  -0.395592
  [12]  =  -0.395592
  [13]  =  0.032075
  [14]  =  -0.395592
  [15]  =  -0.395592, [0.0579561], 2)

</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch_dynamics.jl#L110-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.execute_all_measured-Tuple{QuantumWalk.QWSearch{#s10,W} where W&lt;:Real where #s10&lt;:QuantumWalk.QWModelDiscr,Int64}" href="#QuantumWalk.execute_all_measured-Tuple{QuantumWalk.QWSearch{#s10,W} where W&lt;:Real where #s10&lt;:QuantumWalk.QWModelDiscr,Int64}"><code>QuantumWalk.execute_all_measured</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">execute_all_measured(qss::QWSearch{&lt;:QWModelDiscr},[ initstate,] runtime)</code></pre><p>Evolve <code>initstate</code> acording to QWSearch <code>qss</code> for time <code>runtime</code>. <code>runtime</code> needs to be nonnegative. The initial state is generated by <code>initial_state(qss)</code> function if not provided.Quantum walk model needs to be discrete. As a result return matrix of type <code>Matrix{Float64}</code> for which <code>i</code>-th column  is measurement probability distribution in <code>i-1</code>-th step.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; execute_all_measured(qss, 2)
4×3 Array{Float64,2}:
 0.25  0.694444  0.0579561
 0.25  0.101852  0.314015
 0.25  0.101852  0.314015
 0.25  0.101852  0.314015

</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch_dynamics.jl#L183-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.maximize_quantum_search" href="#QuantumWalk.maximize_quantum_search"><code>QuantumWalk.maximize_quantum_search</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">maximize_quantum_search(qss::QWSearch{&lt;:QWModelCont} [, maxtime, tstep])</code></pre><p>Determines optimal runtime for continuous quantum walk models. The time is searched in [0, maxtime] interval, with penalty <code>penalty(qss)</code>, which is added. It is recommended for penalty to be nonzero, otherwise time close to 0 is usually returned. Typically small <code>penalty</code> approximately equal to log(n) is enough, but optimal value may depend on the model or graph chosen.</p><p>The optimal time is chosen according to expected runtime, which equals to runtime over probability, which simulates the Bernoulli process based on <code>QWModelCont</code>.</p><p><code>tstep</code> is used for primary grid search to search for determine intervale which is supsected to have small expected runtime. To large value may miss the optimal value, while to small may greatly increase runtime of the algorithm.</p><p><code>maxtime</code> defaults to graph order n, <code>tstep</code> defaults to <code>sqrt(n)/5</code>. <code>QSearchState</code> is returned by deafult without <code>penalty</code>. Note that in general the probability is not maximal</p><pre><code class="language-">julia&gt; using QuantumWalk,LightGraphs

julia&gt; qss = QWSearch(CTQW(CompleteGraph(100)), [1], 0.01, 1.);

julia&gt; result = maximize_quantum_search(qss)
QuantumWalk.QSearchState{Array{Complex{Float64},1},Float64}(Complex{Float64}[0.621142+0.695665im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im  …  0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im, 0.0279736-0.023086im], [0.869767], 12.99636940469214)

julia&gt; expected_runtime(result)
14.94235723559316

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.869767

julia&gt; probability(execute_single(qss, pi*sqrt(100)/2))
1-element Array{Float64,1}:
 1.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/maximizing_function.jl#L4-L44">source</a><div><p>maximize_quantum_search(qss::QWSearch{&lt;:QWModelDiscr} [, runtime, mode])</p><p>Determines optimal runtime for continuous quantum walk models. The time is searched in [0, runtime] interval, with penalty <code>penalty(qss)</code>, which is added. It is recommended for penalty to be nonzero, otherwise time close 0 is returned. Typically small <code>penalty</code> approximately equal to log(n) is enough, but optimal value may depend on the model or graph chosen.</p><p>The optimal time depende on chosen <code>mode</code>:</p><ul><li><p><code>:firstmaxprob</code> stops when probability start to decrease,</p></li><li><p><code>:firstmaxeff</code> stops whene expected runtime start to increase,</p></li><li><p><code>:maxtimeeff</code> chooses exhaustively the time from [0, runtime] with smallest expected time,</p></li><li><p><code>:maxtimeprob</code> chooses exhaustively the time from [0, runtime] with maximal success probability,</p></li><li><p><code>:maxeff</code> (default) finds optimal time with smallest expected time, usually faster</p></li></ul><p>than <code>:maxtimefff</code>.</p><p>Note last three modes always returns optimal time within the interval.</p><p><code>maxtime</code> defaults to graph order n, <code>mode</code> defaults to <code>:maxeff</code>. <code>QSearchState</code> is returned by deafult without <code>penalty</code>.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(200)), [1], 1);

julia&gt; result = maximize_quantum_search(qss);

julia&gt; runtime(result)
7

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.500016

julia&gt; result = maximize_quantum_search(qss, 100, :maxtimeprob);

julia&gt; runtime(result)
40

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.550938</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/maximizing_function.jl#L90-L133">source</a></section><h3><a class="nav-anchor" id="QSearchState-1" href="#QSearchState-1">QSearchState</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.QSearchState" href="#QuantumWalk.QSearchState"><code>QuantumWalk.QSearchState</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">QSearchState(state, probability, runtime)
QSearchState(qss, state, runtime)</code></pre><p>Creates container which consists of <code>state</code>, success probability <code>probability</code> and running time <code>runtime</code>. Validity of <code>probability</code> and <code>runtime</code> is not checked.</p><p>In second case <code>state</code> is measured according to <code>qss</code> is made.</p><pre><code class="language-julia-repl">julia?&gt; 2+2
5

julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0)
QuantumWalk.QSearchState{SparseVector{Float64,Int64},Int64}(  [2 ]  =  0.288675
  [3 ]  =  0.288675
  [4 ]  =  0.288675
  [5 ]  =  0.288675
  [7 ]  =  0.288675
  [8 ]  =  0.288675
  [9 ]  =  0.288675
  [10]  =  0.288675
  [12]  =  0.288675
  [13]  =  0.288675
  [14]  =  0.288675
  [15]  =  0.288675, [0.25], 0)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch.jl#L110-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.state" href="#QuantumWalk.state"><code>QuantumWalk.state</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">state(qsearchstate)</code></pre><p>Returns the state of qsearchstate.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0);

julia&gt; state(result)
16-element SparseVector{Float64,Int64} with 12 stored entries:
  [2 ]  =  0.288675
  [3 ]  =  0.288675
  [4 ]  =  0.288675
  [5 ]  =  0.288675
  [7 ]  =  0.288675
  [8 ]  =  0.288675
  [9 ]  =  0.288675
  [10]  =  0.288675
  [12]  =  0.288675
  [13]  =  0.288675
  [14]  =  0.288675
  [15]  =  0.288675</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch.jl#L156-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.probability" href="#QuantumWalk.probability"><code>QuantumWalk.probability</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">probability(qsearchstate)</code></pre><p>Returns the list of probabilities of finding marked vertices.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0);

julia&gt; probability(result)
1-element Array{Float64,1}:
 0.25
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch.jl#L184-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.runtime" href="#QuantumWalk.runtime"><code>QuantumWalk.runtime</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">runtime(qsearchstate)</code></pre><p>Returns the time for which the state was calulated.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = QSearchState(qss, initial_state(qss), 0);

julia&gt; runtime(result)
0
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch.jl#L202-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="QuantumWalk.expected_runtime" href="#QuantumWalk.expected_runtime"><code>QuantumWalk.expected_runtime</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">expected_runtime(runtime, probability)
expected_runtime(state)</code></pre><p>Returns the expected runtime needed for quantum walk, considering it as Bernoulli process. It equals to <code>runtime/probability</code>. In the case of <code>state</code> provided the measurement is made.</p><pre><code class="language-julia-repl">julia&gt; qss = QWSearch(Szegedy(CompleteGraph(4)), [1]);

julia&gt; result = execute(qss, 4);

julia&gt; expected_runtime(result)
6.930377097077988

julia&gt; expected_runtime(runtime(result), sum(probability(result)))
6.930377097077988</code></pre></div><a class="source-link" target="_blank" href="https://github.com/QuantumWalks/QuantumWalk.jl/blob/790bd37fa4c1c3d39cd09e899f38913f9cd366f5/src/qwsearch/qwsearch_util.jl#L23-L42">source</a></section><footer><hr/><a class="previous" href="quantum_walk.html"><span class="direction">Previous</span><span class="title">Quantum walk simulator</span></a><a class="next" href="ctqw.html"><span class="direction">Next</span><span class="title">CTQW model</span></a></footer></article></body></html>
